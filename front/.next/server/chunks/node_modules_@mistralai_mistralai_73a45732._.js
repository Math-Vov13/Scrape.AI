module.exports = {

"[project]/node_modules/@mistralai/mistralai/lib/url.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pathToFunc = pathToFunc;
const hasOwn = Object.prototype.hasOwnProperty;
function pathToFunc(pathPattern, options) {
    const paramRE = /\{([a-zA-Z0-9_]+?)\}/g;
    return function buildURLPath(params = {}) {
        return pathPattern.replace(paramRE, function(_, placeholder) {
            if (!hasOwn.call(params, placeholder)) {
                throw new Error(`Parameter '${placeholder}' is required`);
            }
            const value = params[placeholder];
            if (typeof value !== "string" && typeof value !== "number") {
                throw new Error(`Parameter '${placeholder}' must be a string or number`);
            }
            return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
        });
    };
} //# sourceMappingURL=url.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/config.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SDK_METADATA = exports.ServerList = exports.ServerEu = void 0;
exports.serverURLFromOptions = serverURLFromOptions;
const url_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/url.js [app-route] (ecmascript)");
/**
 * EU Production server
 */ exports.ServerEu = "eu";
/**
 * Contains the list of servers available to the SDK
 */ exports.ServerList = {
    [exports.ServerEu]: "https://api.mistral.ai"
};
function serverURLFromOptions(options) {
    let serverURL = options.serverURL;
    const params = {};
    if (!serverURL) {
        const server = options.server ?? exports.ServerEu;
        serverURL = exports.ServerList[server] || "";
    }
    const u = (0, url_js_1.pathToFunc)(serverURL)(params);
    return new URL(u);
}
exports.SDK_METADATA = {
    language: "typescript",
    openapiDocVersion: "1.0.0",
    sdkVersion: "1.7.0",
    genVersion: "2.548.6",
    userAgent: "speakeasy-sdk/typescript 1.7.0 2.548.6 1.0.0 @mistralai/mistralai"
}; //# sourceMappingURL=config.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/files.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readableStreamToArrayBuffer = readableStreamToArrayBuffer;
/**
 * Consumes a stream and returns a concatenated array buffer. Useful in
 * situations where we need to read the whole file because it forms part of a
 * larger payload containing other fields, and we can't modify the underlying
 * request structure.
 */ async function readableStreamToArrayBuffer(readable) {
    const reader = readable.getReader();
    const chunks = [];
    let totalLength = 0;
    let done = false;
    while(!done){
        const { value, done: doneReading } = await reader.read();
        if (doneReading) {
            done = true;
        } else {
            chunks.push(value);
            totalLength += value.length;
        }
    }
    const concatenatedChunks = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks){
        concatenatedChunks.set(chunk, offset);
        offset += chunk.length;
    }
    return concatenatedChunks.buffer;
} //# sourceMappingURL=files.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/base64.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.zodInbound = exports.zodOutbound = void 0;
exports.bytesToBase64 = bytesToBase64;
exports.bytesFromBase64 = bytesFromBase64;
exports.stringToBytes = stringToBytes;
exports.stringFromBytes = stringFromBytes;
exports.stringToBase64 = stringToBase64;
exports.stringFromBase64 = stringFromBase64;
const z = __importStar(__turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)"));
function bytesToBase64(u8arr) {
    return btoa(String.fromCodePoint(...u8arr));
}
function bytesFromBase64(encoded) {
    return Uint8Array.from(atob(encoded), (c)=>c.charCodeAt(0));
}
function stringToBytes(str) {
    return new TextEncoder().encode(str);
}
function stringFromBytes(u8arr) {
    return new TextDecoder().decode(u8arr);
}
function stringToBase64(str) {
    return bytesToBase64(stringToBytes(str));
}
function stringFromBase64(b64str) {
    return stringFromBytes(bytesFromBase64(b64str));
}
exports.zodOutbound = z.instanceof(Uint8Array).or(z.string().transform(stringToBytes));
exports.zodInbound = z.instanceof(Uint8Array).or(z.string().transform(bytesFromBase64)); //# sourceMappingURL=base64.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/is-plain-object.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPlainObject = isPlainObject;
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ // Taken from https://github.com/sindresorhus/is-plain-obj/blob/97f38e8836f86a642cce98fc6ab3058bc36df181/index.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
} //# sourceMappingURL=is-plain-object.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/encodings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeDeepObjectQuery = exports.encodePipeDelimitedQuery = exports.encodeSpaceDelimitedQuery = exports.encodeFormQuery = exports.encodeJSONQuery = exports.encodeSimple = exports.encodePipeDelimited = exports.encodeSpaceDelimited = exports.encodeForm = exports.EncodingError = void 0;
exports.encodeMatrix = encodeMatrix;
exports.encodeLabel = encodeLabel;
exports.encodeBodyForm = encodeBodyForm;
exports.encodeDeepObject = encodeDeepObject;
exports.encodeDeepObjectObject = encodeDeepObjectObject;
exports.encodeJSON = encodeJSON;
exports.queryJoin = queryJoin;
exports.queryEncoder = queryEncoder;
exports.appendForm = appendForm;
const base64_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/base64.js [app-route] (ecmascript)");
const is_plain_object_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/is-plain-object.js [app-route] (ecmascript)");
class EncodingError extends Error {
    constructor(message){
        super(message);
        this.name = "EncodingError";
    }
}
exports.EncodingError = EncodingError;
function encodeMatrix(key, value, options) {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    if (pairs.every(([_, v])=>v == null)) {
        return;
    }
    const encodeString = (v)=>{
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let tmp = "";
        let encValue = null;
        if (pv == null) {
            return;
        } else if (Array.isArray(pv)) {
            encValue = mapDefined(pv, (v)=>`${encodeValue(v)}`)?.join(",");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            const mapped = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                return `,${encodeString(k)},${encodeValue(v)}`;
            });
            encValue = mapped?.join("").slice(1);
        } else {
            encValue = `${encodeValue(pv)}`;
        }
        if (encValue == null) {
            return;
        }
        const keyPrefix = encodeString(pk);
        tmp = `${keyPrefix}=${encValue}`;
        // trim trailing '=' if value was empty
        if (tmp === `${keyPrefix}=`) {
            tmp = tmp.slice(0, -1);
        }
        // If we end up with the nothing then skip forward
        if (!tmp) {
            return;
        }
        out += `;${tmp}`;
    });
    return out;
}
function encodeLabel(key, value, options) {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    if (pairs.every(([_, v])=>v == null)) {
        return;
    }
    const encodeString = (v)=>{
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let encValue = "";
        if (pv == null) {
            return;
        } else if (Array.isArray(pv)) {
            encValue = mapDefined(pv, (v)=>`${encodeValue(v)}`)?.join(".");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            const mapped = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                return `.${encodeString(k)}.${encodeValue(v)}`;
            });
            encValue = mapped?.join("").slice(1);
        } else {
            const k = options?.explode && (0, is_plain_object_js_1.isPlainObject)(value) ? `${encodeString(pk)}=` : "";
            encValue = `${k}${encodeValue(pv)}`;
        }
        out += encValue == null ? "" : `.${encValue}`;
    });
    return out;
}
function formEncoder(sep) {
    return (key, value, options)=>{
        let out = "";
        const pairs = options?.explode ? explode(key, value) : [
            [
                key,
                value
            ]
        ];
        if (pairs.every(([_, v])=>v == null)) {
            return;
        }
        const encodeString = (v)=>{
            return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
        };
        const encodeValue = (v)=>encodeString(serializeValue(v));
        const encodedSep = encodeString(sep);
        pairs.forEach(([pk, pv])=>{
            let tmp = "";
            let encValue = null;
            if (pv == null) {
                return;
            } else if (Array.isArray(pv)) {
                encValue = mapDefined(pv, (v)=>`${encodeValue(v)}`)?.join(encodedSep);
            } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
                encValue = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                    return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
                })?.join(encodedSep);
            } else {
                encValue = `${encodeValue(pv)}`;
            }
            if (encValue == null) {
                return;
            }
            tmp = `${encodeString(pk)}=${encValue}`;
            // If we end up with the nothing then skip forward
            if (!tmp || tmp === "=") {
                return;
            }
            out += `&${tmp}`;
        });
        return out.slice(1);
    };
}
exports.encodeForm = formEncoder(",");
exports.encodeSpaceDelimited = formEncoder(" ");
exports.encodePipeDelimited = formEncoder("|");
function encodeBodyForm(key, value, options) {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    const encodeString = (v)=>{
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let tmp = "";
        let encValue = "";
        if (pv == null) {
            return;
        } else if (Array.isArray(pv)) {
            encValue = JSON.stringify(pv, jsonReplacer);
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            encValue = JSON.stringify(pv, jsonReplacer);
        } else {
            encValue = `${encodeValue(pv)}`;
        }
        tmp = `${encodeString(pk)}=${encValue}`;
        // If we end up with the nothing then skip forward
        if (!tmp || tmp === "=") {
            return;
        }
        out += `&${tmp}`;
    });
    return out.slice(1);
}
function encodeDeepObject(key, value, options) {
    if (value == null) {
        return;
    }
    if (!(0, is_plain_object_js_1.isPlainObject)(value)) {
        throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
    }
    return encodeDeepObjectObject(key, value, options);
}
function encodeDeepObjectObject(key, value, options) {
    if (value == null) {
        return;
    }
    let out = "";
    const encodeString = (v)=>{
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    if (!(0, is_plain_object_js_1.isPlainObject)(value)) {
        throw new EncodingError(`Expected parameter '${key}' to be an object.`);
    }
    Object.entries(value).forEach(([ck, cv])=>{
        if (cv == null) {
            return;
        }
        const pk = `${key}[${ck}]`;
        if ((0, is_plain_object_js_1.isPlainObject)(cv)) {
            const objOut = encodeDeepObjectObject(pk, cv, options);
            out += objOut == null ? "" : `&${objOut}`;
            return;
        }
        const pairs = Array.isArray(cv) ? cv : [
            cv
        ];
        const encoded = mapDefined(pairs, (v)=>{
            return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
        })?.join("&");
        out += encoded == null ? "" : `&${encoded}`;
    });
    return out.slice(1);
}
function encodeJSON(key, value, options) {
    if (typeof value === "undefined") {
        return;
    }
    const encodeString = (v)=>{
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encVal = encodeString(JSON.stringify(value, jsonReplacer));
    return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
}
const encodeSimple = (key, value, options)=>{
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    if (pairs.every(([_, v])=>v == null)) {
        return;
    }
    const encodeString = (v)=>{
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let tmp = "";
        if (pv == null) {
            return;
        } else if (Array.isArray(pv)) {
            tmp = mapDefined(pv, (v)=>`${encodeValue(v)}`)?.join(",");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            const mapped = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                return `,${encodeString(k)},${encodeValue(v)}`;
            });
            tmp = mapped?.join("").slice(1);
        } else {
            const k = options?.explode && (0, is_plain_object_js_1.isPlainObject)(value) ? `${pk}=` : "";
            tmp = `${k}${encodeValue(pv)}`;
        }
        out += tmp ? `,${tmp}` : "";
    });
    return out.slice(1);
};
exports.encodeSimple = encodeSimple;
function explode(key, value) {
    if (Array.isArray(value)) {
        return value.map((v)=>[
                key,
                v
            ]);
    } else if ((0, is_plain_object_js_1.isPlainObject)(value)) {
        const o = value ?? {};
        return Object.entries(o).map(([k, v])=>[
                k,
                v
            ]);
    } else {
        return [
            [
                key,
                value
            ]
        ];
    }
}
function serializeValue(value) {
    if (value == null) {
        return "";
    } else if (value instanceof Date) {
        return value.toISOString();
    } else if (value instanceof Uint8Array) {
        return (0, base64_js_1.bytesToBase64)(value);
    } else if (typeof value === "object") {
        return JSON.stringify(value, jsonReplacer);
    }
    return `${value}`;
}
function jsonReplacer(_, value) {
    if (value instanceof Uint8Array) {
        return (0, base64_js_1.bytesToBase64)(value);
    } else {
        return value;
    }
}
function mapDefined(inp, mapper) {
    const res = inp.reduce((acc, v)=>{
        if (v == null) {
            return acc;
        }
        const m = mapper(v);
        if (m == null) {
            return acc;
        }
        acc.push(m);
        return acc;
    }, []);
    return res.length ? res : null;
}
function mapDefinedEntries(inp, mapper) {
    const acc = [];
    for (const [k, v] of inp){
        if (v == null) {
            continue;
        }
        const m = mapper([
            k,
            v
        ]);
        if (m == null) {
            continue;
        }
        acc.push(m);
    }
    return acc.length ? acc : null;
}
function queryJoin(...args) {
    return args.filter(Boolean).join("&");
}
function queryEncoder(f) {
    const bulkEncode = function(values, options) {
        const opts = {
            ...options,
            explode: options?.explode ?? true,
            charEncoding: options?.charEncoding ?? "percent"
        };
        const encoded = Object.entries(values).map(([key, value])=>{
            return f(key, value, opts);
        });
        return queryJoin(...encoded);
    };
    return bulkEncode;
}
exports.encodeJSONQuery = queryEncoder(encodeJSON);
exports.encodeFormQuery = queryEncoder(exports.encodeForm);
exports.encodeSpaceDelimitedQuery = queryEncoder(exports.encodeSpaceDelimited);
exports.encodePipeDelimitedQuery = queryEncoder(exports.encodePipeDelimited);
exports.encodeDeepObjectQuery = queryEncoder(encodeDeepObject);
function appendForm(fd, key, value, fileName) {
    if (value == null) {
        return;
    } else if (value instanceof Blob && fileName) {
        fd.append(key, value, fileName);
    } else if (value instanceof Blob) {
        fd.append(key, value);
    } else {
        fd.append(key, String(value));
    }
} //# sourceMappingURL=encodings.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/dlv.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dlv = dlv;
/*
MIT License

Copyright (c) 2024 Jason Miller <jason@developit.ca> (http://jasonformat.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ /**
 * @param obj The object to walk
 * @param key The key path to walk the object with
 * @param def A default value to return if the result is undefined
 *
 * @example
 * dlv(obj, "a.b.c.d")
 * @example
 * dlv(object, ["a", "b", "c", "d"])
 * @example
 * dlv(object, "foo.bar.baz", "Hello, default value!")
 */ function dlv(obj, key, def, p, undef) {
    key = Array.isArray(key) ? key : key.split(".");
    for(p = 0; p < key.length; p++){
        const k = key[p];
        obj = k != null && obj ? obj[k] : undef;
    }
    return obj === undef ? def : obj;
} //# sourceMappingURL=dlv.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/env.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.envSchema = void 0;
exports.env = env;
exports.resetEnv = resetEnv;
const dlv_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/dlv.js [app-route] (ecmascript)");
const z = __importStar(__turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)"));
exports.envSchema = z.object({
    MISTRAL_API_KEY: z.string().optional(),
    MISTRAL_DEBUG: z.coerce.boolean().optional()
});
let envMemo = undefined;
/**
 * Reads and validates environment variables.
 */ function env() {
    if (envMemo) {
        return envMemo;
    }
    envMemo = exports.envSchema.parse((0, dlv_js_1.dlv)(globalThis, "process.env") ?? (0, dlv_js_1.dlv)(globalThis, "Deno.env") ?? {});
    return envMemo;
}
/**
 * Clears the cached env object. Useful for testing with a fresh environment.
 */ function resetEnv() {
    envMemo = undefined;
} //# sourceMappingURL=env.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/http.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HTTPClient = void 0;
exports.matchContentType = matchContentType;
exports.matchStatusCode = matchStatusCode;
exports.matchResponse = matchResponse;
exports.isConnectionError = isConnectionError;
exports.isTimeoutError = isTimeoutError;
exports.isAbortError = isAbortError;
const DEFAULT_FETCHER = (input, init)=>{
    // If input is a Request and init is undefined, Bun will discard the method,
    // headers, body and other options that were set on the request object.
    // Node.js and browers would ignore an undefined init value. This check is
    // therefore needed for interop with Bun.
    if (init == null) {
        return fetch(input);
    } else {
        return fetch(input, init);
    }
};
class HTTPClient {
    constructor(options = {}){
        this.options = options;
        this.requestHooks = [];
        this.requestErrorHooks = [];
        this.responseHooks = [];
        this.fetcher = options.fetcher || DEFAULT_FETCHER;
    }
    async request(request) {
        let req = request;
        for (const hook of this.requestHooks){
            const nextRequest = await hook(req);
            if (nextRequest) {
                req = nextRequest;
            }
        }
        try {
            const res = await this.fetcher(req);
            for (const hook of this.responseHooks){
                await hook(res, req);
            }
            return res;
        } catch (err) {
            for (const hook of this.requestErrorHooks){
                await hook(err, req);
            }
            throw err;
        }
    }
    addHook(...args) {
        if (args[0] === "beforeRequest") {
            this.requestHooks.push(args[1]);
        } else if (args[0] === "requestError") {
            this.requestErrorHooks.push(args[1]);
        } else if (args[0] === "response") {
            this.responseHooks.push(args[1]);
        } else {
            throw new Error(`Invalid hook type: ${args[0]}`);
        }
        return this;
    }
    removeHook(...args) {
        let target;
        if (args[0] === "beforeRequest") {
            target = this.requestHooks;
        } else if (args[0] === "requestError") {
            target = this.requestErrorHooks;
        } else if (args[0] === "response") {
            target = this.responseHooks;
        } else {
            throw new Error(`Invalid hook type: ${args[0]}`);
        }
        const index = target.findIndex((v)=>v === args[1]);
        if (index >= 0) {
            target.splice(index, 1);
        }
        return this;
    }
    clone() {
        const child = new HTTPClient(this.options);
        child.requestHooks = this.requestHooks.slice();
        child.requestErrorHooks = this.requestErrorHooks.slice();
        child.responseHooks = this.responseHooks.slice();
        return child;
    }
}
exports.HTTPClient = HTTPClient;
// A semicolon surrounded by optional whitespace characters is used to separate
// segments in a media type string.
const mediaParamSeparator = /\s*;\s*/g;
function matchContentType(response, pattern) {
    // `*` is a special case which means anything is acceptable.
    if (pattern === "*") {
        return true;
    }
    let contentType = response.headers.get("content-type")?.trim() || "application/octet-stream";
    contentType = contentType.toLowerCase();
    const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
    const [wantType = "", ...wantParams] = wantParts;
    if (wantType.split("/").length !== 2) {
        return false;
    }
    const gotParts = contentType.split(mediaParamSeparator);
    const [gotType = "", ...gotParams] = gotParts;
    const [type = "", subtype = ""] = gotType.split("/");
    if (!type || !subtype) {
        return false;
    }
    if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
        return false;
    }
    if (gotParams.length < wantParams.length) {
        return false;
    }
    const params = new Set(gotParams);
    for (const wantParam of wantParams){
        if (!params.has(wantParam)) {
            return false;
        }
    }
    return true;
}
const codeRangeRE = new RegExp("^[0-9]xx$", "i");
function matchStatusCode(response, codes) {
    const actual = `${response.status}`;
    const expectedCodes = Array.isArray(codes) ? codes : [
        codes
    ];
    if (!expectedCodes.length) {
        return false;
    }
    return expectedCodes.some((ec)=>{
        const code = `${ec}`;
        if (code === "default") {
            return true;
        }
        if (!codeRangeRE.test(`${code}`)) {
            return code === actual;
        }
        const expectFamily = code.charAt(0);
        if (!expectFamily) {
            throw new Error("Invalid status code range");
        }
        const actualFamily = actual.charAt(0);
        if (!actualFamily) {
            throw new Error(`Invalid response status code: ${actual}`);
        }
        return actualFamily === expectFamily;
    });
}
function matchResponse(response, code, contentTypePattern) {
    return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
/**
 * Uses various heurisitics to determine if an error is a connection error.
 */ function isConnectionError(err) {
    if (typeof err !== "object" || err == null) {
        return false;
    }
    // Covers fetch in Deno as well
    const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
    const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
    const isBunErr = "name" in err && err.name === "ConnectionError";
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
    return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
/**
 * Uses various heurisitics to determine if an error is a timeout error.
 */ function isTimeoutError(err) {
    if (typeof err !== "object" || err == null) {
        return false;
    }
    // Fetch in browser, Node.js, Bun, Deno
    const isNative = "name" in err && err.name === "TimeoutError";
    const isLegacyNative = "code" in err && err.code === 23;
    // Node.js HTTP client and Axios
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
    return isNative || isLegacyNative || isGenericErr;
}
/**
 * Uses various heurisitics to determine if an error is a abort error.
 */ function isAbortError(err) {
    if (typeof err !== "object" || err == null) {
        return false;
    }
    // Fetch in browser, Node.js, Bun, Deno
    const isNative = "name" in err && err.name === "AbortError";
    const isLegacyNative = "code" in err && err.code === 20;
    // Node.js HTTP client and Axios
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
    return isNative || isLegacyNative || isGenericErr;
} //# sourceMappingURL=http.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/retries.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TemporaryError = exports.PermanentError = void 0;
exports.retry = retry;
const http_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/http.js [app-route] (ecmascript)");
const defaultBackoff = {
    initialInterval: 500,
    maxInterval: 60000,
    exponent: 1.5,
    maxElapsedTime: 3600000
};
/**
 * PermanentError is an error that is not recoverable. Throwing this error will
 * cause a retry loop to terminate.
 */ class PermanentError extends Error {
    constructor(message, options){
        let msg = message;
        if (options?.cause) {
            msg += `: ${options.cause}`;
        }
        super(msg, options);
        this.name = "PermanentError";
        // In older runtimes, the cause field would not have been assigned through
        // the super() call.
        if (typeof this.cause === "undefined") {
            this.cause = options?.cause;
        }
        Object.setPrototypeOf(this, PermanentError.prototype);
    }
}
exports.PermanentError = PermanentError;
/**
 * TemporaryError is an error is used to signal that an HTTP request can be
 * retried as part of a retry loop. If retry attempts are exhausted and this
 * error is thrown, the response will be returned to the caller.
 */ class TemporaryError extends Error {
    constructor(message, response){
        super(message);
        this.response = response;
        this.name = "TemporaryError";
        Object.setPrototypeOf(this, TemporaryError.prototype);
    }
}
exports.TemporaryError = TemporaryError;
async function retry(fetchFn, options) {
    switch(options.config.strategy){
        case "backoff":
            return retryBackoff(wrapFetcher(fetchFn, {
                statusCodes: options.statusCodes,
                retryConnectionErrors: !!options.config.retryConnectionErrors
            }), options.config.backoff ?? defaultBackoff);
        default:
            return await fetchFn();
    }
}
function wrapFetcher(fn, options) {
    return async ()=>{
        try {
            const res = await fn();
            if (isRetryableResponse(res, options.statusCodes)) {
                throw new TemporaryError("Response failed with retryable status code", res);
            }
            return res;
        } catch (err) {
            if (err instanceof TemporaryError) {
                throw err;
            }
            if (options.retryConnectionErrors && ((0, http_js_1.isTimeoutError)(err) || (0, http_js_1.isConnectionError)(err))) {
                throw err;
            }
            throw new PermanentError("Permanent error", {
                cause: err
            });
        }
    };
}
const codeRangeRE = new RegExp("^[0-9]xx$", "i");
function isRetryableResponse(res, statusCodes) {
    const actual = `${res.status}`;
    return statusCodes.some((code)=>{
        if (!codeRangeRE.test(code)) {
            return code === actual;
        }
        const expectFamily = code.charAt(0);
        if (!expectFamily) {
            throw new Error("Invalid status code range");
        }
        const actualFamily = actual.charAt(0);
        if (!actualFamily) {
            throw new Error(`Invalid response status code: ${actual}`);
        }
        return actualFamily === expectFamily;
    });
}
async function retryBackoff(fn, strategy) {
    const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
    const start = Date.now();
    let x = 0;
    while(true){
        try {
            const res = await fn();
            return res;
        } catch (err) {
            if (err instanceof PermanentError) {
                throw err.cause;
            }
            const elapsed = Date.now() - start;
            if (elapsed > maxElapsedTime) {
                if (err instanceof TemporaryError) {
                    return err.response;
                }
                throw err;
            }
            let retryInterval = 0;
            if (err instanceof TemporaryError) {
                retryInterval = retryIntervalFromResponse(err.response);
            }
            if (retryInterval <= 0) {
                retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1000;
            }
            const d = Math.min(retryInterval, maxInterval);
            await delay(d);
            x++;
        }
    }
}
function retryIntervalFromResponse(res) {
    const retryVal = res.headers.get("retry-after") || "";
    if (!retryVal) {
        return 0;
    }
    const parsedNumber = Number(retryVal);
    if (Number.isInteger(parsedNumber)) {
        return parsedNumber * 1000;
    }
    const parsedDate = Date.parse(retryVal);
    if (Number.isInteger(parsedDate)) {
        const deltaMS = parsedDate - Date.now();
        return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
    }
    return 0;
}
async function delay(delay) {
    return new Promise((resolve)=>setTimeout(resolve, delay));
} //# sourceMappingURL=retries.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClientSDK_httpClient, _ClientSDK_hooks, _ClientSDK_logger;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClientSDK = void 0;
const hooks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/hooks/hooks.js [app-route] (ecmascript)");
const httpclienterrors_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/models/errors/httpclienterrors.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
const base64_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/base64.js [app-route] (ecmascript)");
const config_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/config.js [app-route] (ecmascript)");
const encodings_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/encodings.js [app-route] (ecmascript)");
const env_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/env.js [app-route] (ecmascript)");
const http_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/http.js [app-route] (ecmascript)");
const retries_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/retries.js [app-route] (ecmascript)");
const gt = typeof globalThis === "undefined" ? null : globalThis;
const webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
const isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || "undefined" === "object" && typeof window.document !== "undefined";
class ClientSDK {
    constructor(options = {}){
        _ClientSDK_httpClient.set(this, void 0);
        _ClientSDK_hooks.set(this, void 0);
        _ClientSDK_logger.set(this, void 0);
        const opt = options;
        if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof hooks_js_1.SDKHooks) {
            __classPrivateFieldSet(this, _ClientSDK_hooks, opt.hooks, "f");
        } else {
            __classPrivateFieldSet(this, _ClientSDK_hooks, new hooks_js_1.SDKHooks(), "f");
        }
        this._options = {
            ...options,
            hooks: __classPrivateFieldGet(this, _ClientSDK_hooks, "f")
        };
        const url = (0, config_js_1.serverURLFromOptions)(options);
        if (url) {
            url.pathname = url.pathname.replace(/\/+$/, "") + "/";
        }
        const { baseURL, client } = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").sdkInit({
            baseURL: url,
            client: options.httpClient || new http_js_1.HTTPClient()
        });
        this._baseURL = baseURL;
        __classPrivateFieldSet(this, _ClientSDK_httpClient, client, "f");
        __classPrivateFieldSet(this, _ClientSDK_logger, options.debugLogger, "f");
        if (!__classPrivateFieldGet(this, _ClientSDK_logger, "f") && (0, env_js_1.env)().MISTRAL_DEBUG) {
            __classPrivateFieldSet(this, _ClientSDK_logger, console, "f");
        }
    }
    _createRequest(context, conf, options) {
        const { method, path, query, headers: opHeaders, security } = conf;
        const base = conf.baseURL ?? this._baseURL;
        if (!base) {
            return (0, fp_js_1.ERR)(new httpclienterrors_js_1.InvalidRequestError("No base URL provided for operation"));
        }
        const reqURL = new URL(base);
        const inputURL = new URL(path, reqURL);
        if (path) {
            reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
            reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
        }
        let finalQuery = query || "";
        const secQuery = [];
        for (const [k, v] of Object.entries(security?.queryParams || {})){
            const q = (0, encodings_js_1.encodeForm)(k, v, {
                charEncoding: "percent"
            });
            if (typeof q !== "undefined") {
                secQuery.push(q);
            }
        }
        if (secQuery.length) {
            finalQuery += `&${secQuery.join("&")}`;
        }
        if (finalQuery) {
            const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
            reqURL.search = `?${q}`;
        }
        const headers = new Headers(opHeaders);
        const username = security?.basic.username;
        const password = security?.basic.password;
        if (username != null || password != null) {
            const encoded = (0, base64_js_1.stringToBase64)([
                username || "",
                password || ""
            ].join(":"));
            headers.set("Authorization", `Basic ${encoded}`);
        }
        const securityHeaders = new Headers(security?.headers || {});
        for (const [k, v] of securityHeaders){
            headers.set(k, v);
        }
        let cookie = headers.get("cookie") || "";
        for (const [k, v] of Object.entries(security?.cookies || {})){
            cookie += `; ${k}=${v}`;
        }
        cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
        headers.set("cookie", cookie);
        const userHeaders = new Headers(options?.fetchOptions?.headers);
        for (const [k, v] of userHeaders){
            headers.set(k, v);
        }
        // Only set user agent header in non-browser-like environments since CORS
        // policy disallows setting it in browsers e.g. Chrome throws an error.
        if (!isBrowserLike) {
            headers.set(conf.uaHeader ?? "user-agent", config_js_1.SDK_METADATA.userAgent);
        }
        let fetchOptions = options?.fetchOptions;
        if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
            const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
            if (!fetchOptions) {
                fetchOptions = {
                    signal: timeoutSignal
                };
            } else {
                fetchOptions.signal = timeoutSignal;
            }
        }
        if (conf.body instanceof ReadableStream) {
            if (!fetchOptions) {
                fetchOptions = {};
            }
            Object.assign(fetchOptions, {
                duplex: "half"
            });
        }
        let input;
        try {
            input = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
                url: reqURL,
                options: {
                    ...fetchOptions,
                    body: conf.body ?? null,
                    headers,
                    method
                }
            });
        } catch (err) {
            return (0, fp_js_1.ERR)(new httpclienterrors_js_1.UnexpectedClientError("Create request hook failed to execute", {
                cause: err
            }));
        }
        return (0, fp_js_1.OK)(new Request(input.url, input.options));
    }
    async _do(request, options) {
        const { context, errorCodes } = options;
        return (0, retries_js_1.retry)(async ()=>{
            const req = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
            await logRequest(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), req).catch((e)=>__classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log request:", e));
            let response = await __classPrivateFieldGet(this, _ClientSDK_httpClient, "f").request(req);
            try {
                if ((0, http_js_1.matchStatusCode)(response, errorCodes)) {
                    const result = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterError(context, response, null);
                    if (result.error) {
                        throw result.error;
                    }
                    response = result.response || response;
                } else {
                    response = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
                }
            } finally{
                await logResponse(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), response, req).catch((e)=>__classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log response:", e));
            }
            return response;
        }, {
            config: options.retryConfig,
            statusCodes: options.retryCodes
        }).then((r)=>(0, fp_js_1.OK)(r), (err)=>{
            switch(true){
                case (0, http_js_1.isAbortError)(err):
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.RequestAbortedError("Request aborted by client", {
                        cause: err
                    }));
                case (0, http_js_1.isTimeoutError)(err):
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.RequestTimeoutError("Request timed out", {
                        cause: err
                    }));
                case (0, http_js_1.isConnectionError)(err):
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.ConnectionError("Unable to make request", {
                        cause: err
                    }));
                default:
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.UnexpectedClientError("Unexpected HTTP client error", {
                        cause: err
                    }));
            }
        });
    }
}
exports.ClientSDK = ClientSDK;
_ClientSDK_httpClient = new WeakMap(), _ClientSDK_hooks = new WeakMap(), _ClientSDK_logger = new WeakMap();
const jsonLikeContentTypeRE = /^application\/(?:.{0,100}\+)?json/;
async function logRequest(logger, req) {
    if (!logger) {
        return;
    }
    const contentType = req.headers.get("content-type");
    const ct = contentType?.split(";")[0] || "";
    logger.group(`> Request: ${req.method} ${req.url}`);
    logger.group("Headers:");
    for (const [k, v] of req.headers.entries()){
        logger.log(`${k}: ${v}`);
    }
    logger.groupEnd();
    logger.group("Body:");
    switch(true){
        case jsonLikeContentTypeRE.test(ct):
            logger.log(await req.clone().json());
            break;
        case ct.startsWith("text/"):
            logger.log(await req.clone().text());
            break;
        case ct === "multipart/form-data":
            {
                const body = await req.clone().formData();
                for (const [k, v] of body){
                    const vlabel = v instanceof Blob ? "<Blob>" : v;
                    logger.log(`${k}: ${vlabel}`);
                }
                break;
            }
        default:
            logger.log(`<${contentType}>`);
            break;
    }
    logger.groupEnd();
    logger.groupEnd();
}
async function logResponse(logger, res, req) {
    if (!logger) {
        return;
    }
    const contentType = res.headers.get("content-type");
    const ct = contentType?.split(";")[0] || "";
    logger.group(`< Response: ${req.method} ${req.url}`);
    logger.log("Status Code:", res.status, res.statusText);
    logger.group("Headers:");
    for (const [k, v] of res.headers.entries()){
        logger.log(`${k}: ${v}`);
    }
    logger.groupEnd();
    logger.group("Body:");
    switch(true){
        case (0, http_js_1.matchContentType)(res, "application/json") || jsonLikeContentTypeRE.test(ct):
            logger.log(await res.clone().json());
            break;
        case (0, http_js_1.matchContentType)(res, "text/event-stream"):
            logger.log(`<${contentType}>`);
            break;
        case (0, http_js_1.matchContentType)(res, "text/*"):
            logger.log(await res.clone().text());
            break;
        case (0, http_js_1.matchContentType)(res, "multipart/form-data"):
            {
                const body = await res.clone().formData();
                for (const [k, v] of body){
                    const vlabel = v instanceof Blob ? "<Blob>" : v;
                    logger.log(`${k}: ${vlabel}`);
                }
                break;
            }
        default:
            logger.log(`<${contentType}>`);
            break;
    }
    logger.groupEnd();
    logger.groupEnd();
} //# sourceMappingURL=sdks.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/event-streams.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EventStream = void 0;
exports.discardSentinel = discardSentinel;
const LF = 0x0a;
const CR = 0x0d;
const NEWLINE_CHARS = new Set([
    LF,
    CR
]);
const MESSAGE_BOUNDARIES = [
    new Uint8Array([
        CR,
        LF,
        CR,
        LF
    ]),
    new Uint8Array([
        CR,
        CR
    ]),
    new Uint8Array([
        LF,
        LF
    ])
];
class EventStream {
    constructor(init){
        this.stream = init.stream;
        this.decoder = init.decoder;
    }
    async *[Symbol.asyncIterator]() {
        const reader = this.stream.getReader();
        let buffer = new Uint8Array([]);
        let position = 0;
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                const newBuffer = new Uint8Array(buffer.length + value.length);
                newBuffer.set(buffer);
                newBuffer.set(value, buffer.length);
                buffer = newBuffer;
                for(let i = position; i < buffer.length; i++){
                    const boundary = findBoundary(buffer, i);
                    if (boundary == null) {
                        continue;
                    }
                    const chunk = buffer.slice(position, i);
                    position = i + boundary.length;
                    const event = parseEvent(chunk, this.decoder);
                    if (event != null) {
                        yield event;
                    }
                }
                if (position > 0) {
                    buffer = buffer.slice(position);
                    position = 0;
                }
            }
            if (buffer.length > 0) {
                const event = parseEvent(buffer, this.decoder);
                if (event != null) {
                    yield event;
                }
            }
        } catch (e) {
            if (e instanceof Error && e.name === "AbortError") {
                return;
            }
            throw e;
        } finally{
            reader.releaseLock();
        }
    }
}
exports.EventStream = EventStream;
function findBoundary(buffer, start) {
    const char1 = buffer[start];
    const char2 = buffer[start + 1];
    // Don't bother checking if the first two characters are not new line
    // characters.
    if (char1 == null || char2 == null || !NEWLINE_CHARS.has(char1) || !NEWLINE_CHARS.has(char2)) {
        return null;
    }
    for (const s of MESSAGE_BOUNDARIES){
        const seq = peekSequence(start, buffer, s);
        if (seq != null) {
            return seq;
        }
    }
    return null;
}
function peekSequence(position, buffer, sequence) {
    if (sequence.length > buffer.length - position) {
        return null;
    }
    for(let i = 0; i < sequence.length; i++){
        if (buffer[position + i] !== sequence[i]) {
            return null;
        }
    }
    return sequence;
}
function parseEvent(chunk, decoder) {
    if (!chunk.length) {
        return null;
    }
    const td = new TextDecoder();
    const raw = td.decode(chunk);
    const lines = raw.split(/\r?\n|\r/g);
    let publish = false;
    const rawEvent = {};
    for (const line of lines){
        if (!line) {
            continue;
        }
        const delim = line.indexOf(":");
        // Lines starting with a colon are ignored.
        if (delim === 0) {
            continue;
        }
        const field = delim > 0 ? line.substring(0, delim) : "";
        let value = delim > 0 ? line.substring(delim + 1) : "";
        if (value.charAt(0) === " ") {
            value = value.substring(1);
        }
        switch(field){
            case "event":
                {
                    publish = true;
                    rawEvent.event = value;
                    break;
                }
            case "data":
                {
                    publish = true;
                    rawEvent.data ?? (rawEvent.data = "");
                    rawEvent.data += value + "\n";
                    break;
                }
            case "id":
                {
                    publish = true;
                    rawEvent.id = value;
                    break;
                }
            case "retry":
                {
                    const r = parseInt(value, 10);
                    if (!Number.isNaN(r)) {
                        publish = true;
                        rawEvent.retry = r;
                    }
                    break;
                }
        }
    }
    if (!publish) {
        return null;
    }
    if (rawEvent.data != null) {
        rawEvent.data = rawEvent.data.slice(0, -1);
    }
    return decoder(rawEvent);
}
function discardSentinel(stream, sentinel) {
    return new ReadableStream({
        async start (controller) {
            let buffer = new Uint8Array([]);
            let position = 0;
            let done = false;
            let discard = false;
            const rdr = stream.getReader();
            try {
                while(!done){
                    const result = await rdr.read();
                    const value = result.value;
                    done = done || result.done;
                    // We keep consuming from the source to its completion so it can
                    // flush all its contents and release resources.
                    if (discard) {
                        continue;
                    }
                    if (typeof value === "undefined") {
                        continue;
                    }
                    const newBuffer = new Uint8Array(buffer.length + value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(value, buffer.length);
                    buffer = newBuffer;
                    for(let i = position; i < buffer.length; i++){
                        const boundary = findBoundary(buffer, i);
                        if (boundary == null) {
                            continue;
                        }
                        const start = position;
                        const chunk = buffer.slice(start, i);
                        position = i + boundary.length;
                        const event = parseEvent(chunk, id);
                        if (event?.data === sentinel) {
                            controller.enqueue(buffer.slice(0, start));
                            discard = true;
                        } else {
                            controller.enqueue(buffer.slice(0, position));
                            buffer = buffer.slice(position);
                            position = 0;
                        }
                    }
                }
            } catch (e) {
                controller.error(e);
            } finally{
                // If the source stream terminates, flush its contents and terminate.
                // If the sentinel event was found, flush everything up to its start.
                controller.close();
                rdr.releaseLock();
            }
        }
    });
}
function id(v) {
    return v;
} //# sourceMappingURL=event-streams.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/schemas.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;
exports.safeParse = safeParse;
exports.collectExtraKeys = collectExtraKeys;
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
const sdkvalidationerror_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/models/errors/sdkvalidationerror.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
/**
 * Utility function that executes some code which may throw a ZodError. It
 * intercepts this error and converts it to an SDKValidationError so as to not
 * leak Zod implementation details to user code.
 */ function parse(rawValue, fn, errorMessage) {
    try {
        return fn(rawValue);
    } catch (err) {
        if (err instanceof zod_1.ZodError) {
            throw new sdkvalidationerror_js_1.SDKValidationError(errorMessage, err, rawValue);
        }
        throw err;
    }
}
/**
 * Utility function that executes some code which may result in a ZodError. It
 * intercepts this error and converts it to an SDKValidationError so as to not
 * leak Zod implementation details to user code.
 */ function safeParse(rawValue, fn, errorMessage) {
    try {
        return (0, fp_js_1.OK)(fn(rawValue));
    } catch (err) {
        return (0, fp_js_1.ERR)(new sdkvalidationerror_js_1.SDKValidationError(errorMessage, err, rawValue));
    }
}
function collectExtraKeys(obj, extrasKey, optional) {
    return obj.transform((val)=>{
        const extras = {};
        const { shape } = obj;
        for (const [key] of Object.entries(val)){
            if (key in shape) {
                continue;
            }
            const v = val[key];
            if (typeof v === "undefined") {
                continue;
            }
            extras[key] = v;
            delete val[key];
        }
        if (optional && Object.keys(extras).length === 0) {
            return val;
        }
        return {
            ...val,
            [extrasKey]: extras
        };
    });
} //# sourceMappingURL=schemas.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/matchers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jsonErr = jsonErr;
exports.json = json;
exports.textErr = textErr;
exports.text = text;
exports.bytesErr = bytesErr;
exports.bytes = bytes;
exports.streamErr = streamErr;
exports.stream = stream;
exports.sseErr = sseErr;
exports.sse = sse;
exports.nilErr = nilErr;
exports.nil = nil;
exports.fail = fail;
exports.match = match;
exports.unpackHeaders = unpackHeaders;
exports.discardResponseBody = discardResponseBody;
const sdkerror_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/models/errors/sdkerror.js [app-route] (ecmascript)");
const event_streams_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/event-streams.js [app-route] (ecmascript)");
const http_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/http.js [app-route] (ecmascript)");
const is_plain_object_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/is-plain-object.js [app-route] (ecmascript)");
const schemas_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/schemas.js [app-route] (ecmascript)");
const DEFAULT_CONTENT_TYPES = {
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*"
};
function jsonErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "json",
        codes,
        schema
    };
}
function json(codes, schema, options) {
    return {
        ...options,
        enc: "json",
        codes,
        schema
    };
}
function textErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "text",
        codes,
        schema
    };
}
function text(codes, schema, options) {
    return {
        ...options,
        enc: "text",
        codes,
        schema
    };
}
function bytesErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "bytes",
        codes,
        schema
    };
}
function bytes(codes, schema, options) {
    return {
        ...options,
        enc: "bytes",
        codes,
        schema
    };
}
function streamErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "stream",
        codes,
        schema
    };
}
function stream(codes, schema, options) {
    return {
        ...options,
        enc: "stream",
        codes,
        schema
    };
}
function sseErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "sse",
        codes,
        schema
    };
}
function sse(codes, schema, options) {
    return {
        ...options,
        enc: "sse",
        codes,
        schema
    };
}
function nilErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "nil",
        codes,
        schema
    };
}
function nil(codes, schema, options) {
    return {
        ...options,
        enc: "nil",
        codes,
        schema
    };
}
function fail(codes) {
    return {
        enc: "fail",
        codes
    };
}
function match(...matchers) {
    return async function matchFunc(response, options) {
        let raw;
        let matcher;
        for (const match of matchers){
            const { codes } = match;
            const ctpattern = "ctype" in match ? match.ctype : DEFAULT_CONTENT_TYPES[match.enc];
            if (ctpattern && (0, http_js_1.matchResponse)(response, codes, ctpattern)) {
                matcher = match;
                break;
            } else if (!ctpattern && (0, http_js_1.matchStatusCode)(response, codes)) {
                matcher = match;
                break;
            }
        }
        if (!matcher) {
            const responseBody = await response.text();
            return [
                {
                    ok: false,
                    error: new sdkerror_js_1.SDKError("Unexpected API response status or content-type", response, responseBody)
                },
                responseBody
            ];
        }
        const encoding = matcher.enc;
        switch(encoding){
            case "json":
                raw = await response.json();
                break;
            case "bytes":
                raw = new Uint8Array(await response.arrayBuffer());
                break;
            case "stream":
                raw = response.body;
                break;
            case "text":
                raw = await response.text();
                break;
            case "sse":
                raw = response.body && matcher.sseSentinel ? (0, event_streams_js_1.discardSentinel)(response.body, matcher.sseSentinel) : response.body;
                break;
            case "nil":
                raw = await discardResponseBody(response);
                break;
            case "fail":
                raw = await response.text();
                break;
            default:
                encoding;
                throw new Error(`Unsupported response type: ${encoding}`);
        }
        if (matcher.enc === "fail") {
            return [
                {
                    ok: false,
                    error: new sdkerror_js_1.SDKError("API error occurred", response, typeof raw === "string" ? raw : "")
                },
                raw
            ];
        }
        const resultKey = matcher.key || options?.resultKey;
        let data;
        if ("err" in matcher) {
            data = {
                ...options?.extraFields,
                ...matcher.hdrs ? {
                    Headers: unpackHeaders(response.headers)
                } : null,
                ...(0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null
            };
        } else if (resultKey) {
            data = {
                ...options?.extraFields,
                ...matcher.hdrs ? {
                    Headers: unpackHeaders(response.headers)
                } : null,
                [resultKey]: raw
            };
        } else if (matcher.hdrs) {
            data = {
                ...options?.extraFields,
                ...matcher.hdrs ? {
                    Headers: unpackHeaders(response.headers)
                } : null,
                ...(0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null
            };
        } else {
            data = raw;
        }
        if ("err" in matcher) {
            const result = (0, schemas_js_1.safeParse)(data, (v)=>matcher.schema.parse(v), "Response validation failed");
            return [
                result.ok ? {
                    ok: false,
                    error: result.value
                } : result,
                raw
            ];
        } else {
            return [
                (0, schemas_js_1.safeParse)(data, (v)=>matcher.schema.parse(v), "Response validation failed"),
                raw
            ];
        }
    };
}
const headerValRE = /, */;
/**
 * Iterates over a Headers object and returns an object with all the header
 * entries. Values are represented as an array to account for repeated headers.
 */ function unpackHeaders(headers) {
    const out = {};
    for (const [k, v] of headers.entries()){
        out[k] = v.split(headerValRE);
    }
    return out;
}
/**
 * Discards the response body to free up resources.
 *
 * To learn why this is need, see the undici docs:
 * https://undici.nodejs.org/#/?id=garbage-collection
 */ async function discardResponseBody(res) {
    const reader = res.body?.getReader();
    if (reader == null) {
        return;
    }
    try {
        let done = false;
        while(!done){
            const res = await reader.read();
            done = res.done;
        }
    } finally{
        reader.releaseLock();
    }
} //# sourceMappingURL=matchers.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/primitives.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.invariant = invariant;
exports.remap = remap;
exports.combineSignals = combineSignals;
exports.abortSignalAny = abortSignalAny;
exports.compactMap = compactMap;
exports.allRequired = allRequired;
class InvariantError extends Error {
    constructor(message){
        super(message);
        this.name = "InvariantError";
    }
}
function invariant(condition, message) {
    if (!condition) {
        throw new InvariantError(message);
    }
}
/**
 * Converts or omits an object's keys according to a mapping.
 *
 * @param inp An object whose keys will be remapped
 * @param mappings A mapping of original keys to new keys. If a key is not present in the mapping, it will be left as is. If a key is mapped to `null`, it will be removed in the resulting object.
 * @returns A new object with keys remapped or omitted according to the mappings
 */ function remap(inp, mappings) {
    let out = {};
    if (!Object.keys(mappings).length) {
        out = inp;
        return out;
    }
    for (const [k, v] of Object.entries(inp)){
        const j = mappings[k];
        if (j === null) {
            continue;
        }
        out[j ?? k] = v;
    }
    return out;
}
function combineSignals(...signals) {
    const filtered = [];
    for (const signal of signals){
        if (signal) {
            filtered.push(signal);
        }
    }
    switch(filtered.length){
        case 0:
        case 1:
            return filtered[0] || null;
        default:
            if ("any" in AbortSignal && typeof AbortSignal.any === "function") {
                return AbortSignal.any(filtered);
            }
            return abortSignalAny(filtered);
    }
}
function abortSignalAny(signals) {
    const controller = new AbortController();
    const result = controller.signal;
    if (!signals.length) {
        return controller.signal;
    }
    if (signals.length === 1) {
        return signals[0] || controller.signal;
    }
    for (const signal of signals){
        if (signal.aborted) {
            return signal;
        }
    }
    function abort() {
        controller.abort(this.reason);
        clean();
    }
    const signalRefs = [];
    function clean() {
        for (const signalRef of signalRefs){
            const signal = signalRef.deref();
            if (signal) {
                signal.removeEventListener("abort", abort);
            }
        }
    }
    for (const signal of signals){
        signalRefs.push(new WeakRef(signal));
        signal.addEventListener("abort", abort);
    }
    return result;
}
function compactMap(values) {
    const out = {};
    for (const [k, v] of Object.entries(values)){
        if (typeof v !== "undefined") {
            out[k] = v;
        }
    }
    return out;
}
function allRequired(v) {
    if (Object.values(v).every((x)=>x == null)) {
        return void 0;
    }
    return v;
} //# sourceMappingURL=primitives.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/lib/security.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SecurityError = exports.SecurityErrorCode = void 0;
exports.resolveSecurity = resolveSecurity;
exports.resolveGlobalSecurity = resolveGlobalSecurity;
exports.extractSecurity = extractSecurity;
const env_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/env.js [app-route] (ecmascript)");
var SecurityErrorCode;
(function(SecurityErrorCode) {
    SecurityErrorCode["Incomplete"] = "incomplete";
    SecurityErrorCode["UnrecognisedSecurityType"] = "unrecognized_security_type";
})(SecurityErrorCode || (exports.SecurityErrorCode = SecurityErrorCode = {}));
class SecurityError extends Error {
    constructor(code, message){
        super(message);
        this.code = code;
        this.name = "SecurityError";
    }
    static incomplete() {
        return new SecurityError(SecurityErrorCode.Incomplete, "Security requirements not met in order to perform the operation");
    }
    static unrecognizedType(type) {
        return new SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);
    }
}
exports.SecurityError = SecurityError;
function resolveSecurity(...options) {
    const state = {
        basic: {},
        headers: {},
        queryParams: {},
        cookies: {},
        oauth2: {
            type: "none"
        }
    };
    const option = options.find((opts)=>{
        return opts.every((o)=>{
            if (o.value == null) {
                return false;
            } else if (o.type === "http:basic") {
                return o.value.username != null || o.value.password != null;
            } else if (o.type === "http:custom") {
                return null;
            } else if (o.type === "oauth2:password") {
                return typeof o.value === "string" && !!o.value;
            } else if (o.type === "oauth2:client_credentials") {
                return o.value.clientID != null || o.value.clientSecret != null;
            } else if (typeof o.value === "string") {
                return !!o.value;
            } else {
                throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);
            }
        });
    });
    if (option == null) {
        return null;
    }
    option.forEach((spec)=>{
        if (spec.value == null) {
            return;
        }
        const { type } = spec;
        switch(type){
            case "apiKey:header":
                state.headers[spec.fieldName] = spec.value;
                break;
            case "apiKey:query":
                state.queryParams[spec.fieldName] = spec.value;
                break;
            case "apiKey:cookie":
                state.cookies[spec.fieldName] = spec.value;
                break;
            case "http:basic":
                applyBasic(state, spec);
                break;
            case "http:custom":
                break;
            case "http:bearer":
                applyBearer(state, spec);
                break;
            case "oauth2":
                applyBearer(state, spec);
                break;
            case "oauth2:password":
                applyBearer(state, spec);
                break;
            case "oauth2:client_credentials":
                break;
            case "openIdConnect":
                applyBearer(state, spec);
                break;
            default:
                spec;
                throw SecurityError.unrecognizedType(type);
        }
    });
    return state;
}
function applyBasic(state, spec) {
    if (spec.value == null) {
        return;
    }
    state.basic = spec.value;
}
function applyBearer(state, spec) {
    if (typeof spec.value !== "string" || !spec.value) {
        return;
    }
    let value = spec.value;
    if (value.slice(0, 7).toLowerCase() !== "bearer ") {
        value = `Bearer ${value}`;
    }
    state.headers[spec.fieldName] = value;
}
function resolveGlobalSecurity(security) {
    return resolveSecurity([
        {
            fieldName: "Authorization",
            type: "http:bearer",
            value: security?.apiKey ?? (0, env_js_1.env)().MISTRAL_API_KEY
        }
    ]);
}
async function extractSecurity(sec) {
    if (sec == null) {
        return;
    }
    return typeof sec === "function" ? sec() : sec;
} //# sourceMappingURL=security.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/hooks/custom_user_agent.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomUserAgentHook = void 0;
const config_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/config.js [app-route] (ecmascript)");
class CustomUserAgentHook {
    beforeRequest(_, request) {
        const version = config_1.SDK_METADATA.sdkVersion;
        const ua = `mistral-client-typescript/${version}`;
        request.headers.set("user-agent", ua);
        // In Chrome, the line above may silently fail. If the header was not set
        // we fallback to setting an alternate header.
        // Chromium bug: https://issues.chromium.org/issues/40450316
        if (!request.headers.get("user-agent")) {
            request.headers.set("x-mistral-user-agent", ua);
        }
        return request;
    }
}
exports.CustomUserAgentHook = CustomUserAgentHook; //# sourceMappingURL=custom_user_agent.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/hooks/deprecation_warning.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeprecationWarningHook = void 0;
const HEADER_MODEL_DEPRECATION_TIMESTAMP = "x-model-deprecation-timestamp";
class DeprecationWarningHook {
    afterSuccess(_, response) {
        if (response.headers.has(HEADER_MODEL_DEPRECATION_TIMESTAMP)) {
            response.clone().json().then((body)=>{
                const model = body.model;
                console.warn(`WARNING: The model ${model} is deprecated and will be removed on ${response.headers.get(HEADER_MODEL_DEPRECATION_TIMESTAMP)}. Please refer to https://docs.mistral.ai/getting-started/models/#api-versioning for more information.`);
            });
        }
        return response;
    }
}
exports.DeprecationWarningHook = DeprecationWarningHook; //# sourceMappingURL=deprecation_warning.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/hooks/registration.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.initHooks = initHooks;
const custom_user_agent_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/hooks/custom_user_agent.js [app-route] (ecmascript)");
const deprecation_warning_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/hooks/deprecation_warning.js [app-route] (ecmascript)");
/*
 * This file is only ever generated once on the first generation and then is free to be modified.
 * Any hooks you wish to add should be registered in the initHooks function. Feel free to define them
 * in this file or in separate files in the hooks folder.
 */ function initHooks(hooks) {
    // Add hooks by calling hooks.register{ClientInit/BeforeCreateRequest/BeforeRequest/AfterSuccess/AfterError}Hook
    // with an instance of a hook that implements that specific Hook interface
    // Hooks are registered per SDK instance, and are valid for the lifetime of the SDK instance
    const customUserAgentHook = new custom_user_agent_1.CustomUserAgentHook();
    hooks.registerBeforeRequestHook(customUserAgentHook);
    const deprecationWarningHook = new deprecation_warning_1.DeprecationWarningHook();
    hooks.registerAfterSuccessHook(deprecationWarningHook);
} //# sourceMappingURL=registration.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/hooks/hooks.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SDKHooks = void 0;
const registration_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/hooks/registration.js [app-route] (ecmascript)");
class SDKHooks {
    constructor(){
        this.sdkInitHooks = [];
        this.beforeCreateRequestHooks = [];
        this.beforeRequestHooks = [];
        this.afterSuccessHooks = [];
        this.afterErrorHooks = [];
        const presetHooks = [];
        for (const hook of presetHooks){
            if ("sdkInit" in hook) {
                this.registerSDKInitHook(hook);
            }
            if ("beforeCreateRequest" in hook) {
                this.registerBeforeCreateRequestHook(hook);
            }
            if ("beforeRequest" in hook) {
                this.registerBeforeRequestHook(hook);
            }
            if ("afterSuccess" in hook) {
                this.registerAfterSuccessHook(hook);
            }
            if ("afterError" in hook) {
                this.registerAfterErrorHook(hook);
            }
        }
        (0, registration_js_1.initHooks)(this);
    }
    registerSDKInitHook(hook) {
        this.sdkInitHooks.push(hook);
    }
    registerBeforeCreateRequestHook(hook) {
        this.beforeCreateRequestHooks.push(hook);
    }
    registerBeforeRequestHook(hook) {
        this.beforeRequestHooks.push(hook);
    }
    registerAfterSuccessHook(hook) {
        this.afterSuccessHooks.push(hook);
    }
    registerAfterErrorHook(hook) {
        this.afterErrorHooks.push(hook);
    }
    sdkInit(opts) {
        return this.sdkInitHooks.reduce((opts, hook)=>hook.sdkInit(opts), opts);
    }
    beforeCreateRequest(hookCtx, input) {
        let inp = input;
        for (const hook of this.beforeCreateRequestHooks){
            inp = hook.beforeCreateRequest(hookCtx, inp);
        }
        return inp;
    }
    async beforeRequest(hookCtx, request) {
        let req = request;
        for (const hook of this.beforeRequestHooks){
            req = await hook.beforeRequest(hookCtx, req);
        }
        return req;
    }
    async afterSuccess(hookCtx, response) {
        let res = response;
        for (const hook of this.afterSuccessHooks){
            res = await hook.afterSuccess(hookCtx, res);
        }
        return res;
    }
    async afterError(hookCtx, response, error) {
        let res = response;
        let err = error;
        for (const hook of this.afterErrorHooks){
            const result = await hook.afterError(hookCtx, res, err);
            res = result.response;
            err = result.error;
        }
        return {
            response: res,
            error: err
        };
    }
}
exports.SDKHooks = SDKHooks; //# sourceMappingURL=hooks.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OK = OK;
exports.ERR = ERR;
exports.unwrap = unwrap;
exports.unwrapAsync = unwrapAsync;
function OK(value) {
    return {
        ok: true,
        value
    };
}
function ERR(error) {
    return {
        ok: false,
        error
    };
}
/**
 * unwrap is a convenience function for extracting a value from a result or
 * throwing if there was an error.
 */ function unwrap(r) {
    if (!r.ok) {
        throw r.error;
    }
    return r.value;
}
/**
 * unwrapAsync is a convenience function for resolving a value from a Promise
 * of a result or rejecting if an error occurred.
 */ async function unwrapAsync(pr) {
    const r = await pr;
    if (!r.ok) {
        throw r.error;
    }
    return r.value;
} //# sourceMappingURL=fp.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/types/enums.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.catchUnrecognizedEnum = catchUnrecognizedEnum;
function catchUnrecognizedEnum(value) {
    return value;
} //# sourceMappingURL=enums.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/types/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _APIPromise_promise, _APIPromise_unwrapped, _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.APIPromise = void 0;
class APIPromise {
    constructor(p){
        _APIPromise_promise.set(this, void 0);
        _APIPromise_unwrapped.set(this, void 0);
        this[_a] = "APIPromise";
        __classPrivateFieldSet(this, _APIPromise_promise, p instanceof Promise ? p : Promise.resolve(p), "f");
        __classPrivateFieldSet(this, _APIPromise_unwrapped, p instanceof Promise ? __classPrivateFieldGet(this, _APIPromise_promise, "f").then(([value])=>value) : Promise.resolve(p[0]), "f");
    }
    then(onfulfilled, onrejected) {
        return __classPrivateFieldGet(this, _APIPromise_promise, "f").then(onfulfilled ? ([value])=>onfulfilled(value) : void 0, onrejected);
    }
    catch(onrejected) {
        return __classPrivateFieldGet(this, _APIPromise_unwrapped, "f").catch(onrejected);
    }
    finally(onfinally) {
        return __classPrivateFieldGet(this, _APIPromise_unwrapped, "f").finally(onfinally);
    }
    $inspect() {
        return __classPrivateFieldGet(this, _APIPromise_promise, "f");
    }
}
exports.APIPromise = APIPromise;
_APIPromise_promise = new WeakMap(), _APIPromise_unwrapped = new WeakMap(), _a = Symbol.toStringTag; //# sourceMappingURL=async.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/types/blobs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blobLikeSchema = void 0;
exports.isBlobLike = isBlobLike;
const z = __importStar(__turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)"));
exports.blobLikeSchema = z.custom(isBlobLike, {
    message: "expected a Blob, File or Blob-like object",
    fatal: true
});
function isBlobLike(val) {
    if (val instanceof Blob) {
        return true;
    }
    if (typeof val !== "object" || val == null || !(Symbol.toStringTag in val)) {
        return false;
    }
    const name = val[Symbol.toStringTag];
    if (typeof name !== "string") {
        return false;
    }
    if (name !== "Blob" && name !== "File") {
        return false;
    }
    return "stream" in val && typeof val.stream === "function";
} //# sourceMappingURL=blobs.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/types/streams.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isReadableStream = isReadableStream;
function isReadableStream(val) {
    if (typeof val !== "object" || val === null) {
        return false;
    }
    // Check for the presence of methods specific to ReadableStream
    const stream = val;
    // ReadableStream has methods like getReader, cancel, and tee
    return typeof stream.getReader === "function" && typeof stream.cancel === "function" && typeof stream.tee === "function";
} //# sourceMappingURL=streams.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/agents.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Agents = void 0;
const agentsComplete_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/agentsComplete.js [app-route] (ecmascript)");
const agentsStream_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/agentsStream.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Agents extends sdks_js_1.ClientSDK {
    /**
     * Agents Completion
     */ async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, agentsComplete_js_1.agentsComplete)(this, request, options));
    }
    /**
     * Stream Agents completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */ async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, agentsStream_js_1.agentsStream)(this, request, options));
    }
}
exports.Agents = Agents; //# sourceMappingURL=agents.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/mistraljobs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MistralJobs = void 0;
const batchJobsCancel_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/batchJobsCancel.js [app-route] (ecmascript)");
const batchJobsCreate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/batchJobsCreate.js [app-route] (ecmascript)");
const batchJobsGet_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/batchJobsGet.js [app-route] (ecmascript)");
const batchJobsList_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/batchJobsList.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class MistralJobs extends sdks_js_1.ClientSDK {
    /**
     * Get Batch Jobs
     *
     * @remarks
     * Get a list of batch jobs for your organization and user.
     */ async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsList_js_1.batchJobsList)(this, request, options));
    }
    /**
     * Create Batch Job
     *
     * @remarks
     * Create a new batch job, it will be queued for processing.
     */ async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsCreate_js_1.batchJobsCreate)(this, request, options));
    }
    /**
     * Get Batch Job
     *
     * @remarks
     * Get a batch job details by its UUID.
     */ async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsGet_js_1.batchJobsGet)(this, request, options));
    }
    /**
     * Cancel Batch Job
     *
     * @remarks
     * Request the cancellation of a batch job.
     */ async cancel(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsCancel_js_1.batchJobsCancel)(this, request, options));
    }
}
exports.MistralJobs = MistralJobs; //# sourceMappingURL=mistraljobs.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/batch.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Batch = void 0;
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const mistraljobs_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/mistraljobs.js [app-route] (ecmascript)");
class Batch extends sdks_js_1.ClientSDK {
    get jobs() {
        return this._jobs ?? (this._jobs = new mistraljobs_js_1.MistralJobs(this._options));
    }
}
exports.Batch = Batch; //# sourceMappingURL=batch.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/conversations.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Conversations = void 0;
const betaConversationsAppend_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsAppend.js [app-route] (ecmascript)");
const betaConversationsAppendStream_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsAppendStream.js [app-route] (ecmascript)");
const betaConversationsGet_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsGet.js [app-route] (ecmascript)");
const betaConversationsGetHistory_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsGetHistory.js [app-route] (ecmascript)");
const betaConversationsGetMessages_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsGetMessages.js [app-route] (ecmascript)");
const betaConversationsList_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsList.js [app-route] (ecmascript)");
const betaConversationsRestart_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsRestart.js [app-route] (ecmascript)");
const betaConversationsRestartStream_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsRestartStream.js [app-route] (ecmascript)");
const betaConversationsStart_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsStart.js [app-route] (ecmascript)");
const betaConversationsStartStream_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaConversationsStartStream.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Conversations extends sdks_js_1.ClientSDK {
    /**
     * Create a conversation and append entries to it.
     *
     * @remarks
     * Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.
     */ async start(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsStart_js_1.betaConversationsStart)(this, request, options));
    }
    /**
     * List all created conversations.
     *
     * @remarks
     * Retrieve a list of conversation entities sorted by creation time.
     */ async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsList_js_1.betaConversationsList)(this, request, options));
    }
    /**
     * Retrieve a conversation information.
     *
     * @remarks
     * Given a conversation_id retrieve a conversation entity with its attributes.
     */ async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsGet_js_1.betaConversationsGet)(this, request, options));
    }
    /**
     * Append new entries to an existing conversation.
     *
     * @remarks
     * Run completion on the history of the conversation and the user entries. Return the new created entries.
     */ async append(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsAppend_js_1.betaConversationsAppend)(this, request, options));
    }
    /**
     * Retrieve all entries in a conversation.
     *
     * @remarks
     * Given a conversation_id retrieve all the entries belonging to that conversation. The entries are sorted in the order they were appended, those can be messages, connectors or function_call.
     */ async getHistory(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsGetHistory_js_1.betaConversationsGetHistory)(this, request, options));
    }
    /**
     * Retrieve all messages in a conversation.
     *
     * @remarks
     * Given a conversation_id retrieve all the messages belonging to that conversation. This is similar to retrieving all entries except we filter the messages only.
     */ async getMessages(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsGetMessages_js_1.betaConversationsGetMessages)(this, request, options));
    }
    /**
     * Restart a conversation starting from a given entry.
     *
     * @remarks
     * Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.
     */ async restart(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsRestart_js_1.betaConversationsRestart)(this, request, options));
    }
    /**
     * Create a conversation and append entries to it.
     *
     * @remarks
     * Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.
     */ async startStream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsStartStream_js_1.betaConversationsStartStream)(this, request, options));
    }
    /**
     * Append new entries to an existing conversation.
     *
     * @remarks
     * Run completion on the history of the conversation and the user entries. Return the new created entries.
     */ async appendStream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsAppendStream_js_1.betaConversationsAppendStream)(this, request, options));
    }
    /**
     * Restart a conversation starting from a given entry.
     *
     * @remarks
     * Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.
     */ async restartStream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsRestartStream_js_1.betaConversationsRestartStream)(this, request, options));
    }
}
exports.Conversations = Conversations; //# sourceMappingURL=conversations.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/mistralagents.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MistralAgents = void 0;
const betaAgentsCreate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaAgentsCreate.js [app-route] (ecmascript)");
const betaAgentsGet_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaAgentsGet.js [app-route] (ecmascript)");
const betaAgentsList_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaAgentsList.js [app-route] (ecmascript)");
const betaAgentsUpdate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaAgentsUpdate.js [app-route] (ecmascript)");
const betaAgentsUpdateVersion_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/betaAgentsUpdateVersion.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class MistralAgents extends sdks_js_1.ClientSDK {
    /**
     * Create a agent that can be used within a conversation.
     *
     * @remarks
     * Create a new agent giving it instructions, tools, description. The agent is then available to be used as a regular assistant in a conversation or as part of an agent pool from which it can be used.
     */ async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsCreate_js_1.betaAgentsCreate)(this, request, options));
    }
    /**
     * List agent entities.
     *
     * @remarks
     * Retrieve a list of agent entities sorted by creation time.
     */ async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsList_js_1.betaAgentsList)(this, request, options));
    }
    /**
     * Retrieve an agent entity.
     *
     * @remarks
     * Given an agent retrieve an agent entity with its attributes.
     */ async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsGet_js_1.betaAgentsGet)(this, request, options));
    }
    /**
     * Update an agent entity.
     *
     * @remarks
     * Update an agent attributes and create a new version.
     */ async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsUpdate_js_1.betaAgentsUpdate)(this, request, options));
    }
    /**
     * Update an agent version.
     *
     * @remarks
     * Switch the version of an agent.
     */ async updateVersion(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsUpdateVersion_js_1.betaAgentsUpdateVersion)(this, request, options));
    }
}
exports.MistralAgents = MistralAgents; //# sourceMappingURL=mistralagents.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/beta.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Beta = void 0;
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const conversations_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/conversations.js [app-route] (ecmascript)");
const mistralagents_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/mistralagents.js [app-route] (ecmascript)");
class Beta extends sdks_js_1.ClientSDK {
    get conversations() {
        return this._conversations ?? (this._conversations = new conversations_js_1.Conversations(this._options));
    }
    get agents() {
        return this._agents ?? (this._agents = new mistralagents_js_1.MistralAgents(this._options));
    }
}
exports.Beta = Beta; //# sourceMappingURL=beta.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/chat.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chat = void 0;
const chatComplete_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/chatComplete.js [app-route] (ecmascript)");
const chatStream_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/chatStream.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
const structChat_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/extra/structChat.js [app-route] (ecmascript)");
// #endregion imports
class Chat extends sdks_js_1.ClientSDK {
    // #region sdk-class-body
    /**
     * Chat Completion with the response parsed in the same format as the input requestFormat.
     *
     * @remarks
     * The response will be parsed back to the initial Zod object passed in the requestFormat field.
     */ async parse(request, options) {
        const ccr_request = (0, structChat_js_1.transformToChatCompletionRequest)(request);
        const response = await (0, fp_js_1.unwrapAsync)((0, chatComplete_js_1.chatComplete)(this, ccr_request, options));
        const parsed_response = (0, structChat_js_1.convertToParsedChatCompletionResponse)(response, request.responseFormat);
        return parsed_response;
    }
    /**
     * Stream chat completion with a parsed request input.
     *
     * @remarks
     * Unlike the .parse method, this method will return a stream of events containing the JSON response. It will not be parsed back to the initial Zod object.
     * If you need to parse the stream, see the examples/src/async_structured_outputs.ts file.
     */ async parseStream(request, options) {
        const ccr_request = (0, structChat_js_1.transformToChatCompletionRequest)(request);
        return (0, fp_js_1.unwrapAsync)((0, chatStream_js_1.chatStream)(this, ccr_request, options));
    }
    // #endregion sdk-class-body
    /**
     * Chat Completion
     */ async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, chatComplete_js_1.chatComplete)(this, request, options));
    }
    /**
     * Stream chat completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */ async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, chatStream_js_1.chatStream)(this, request, options));
    }
}
exports.Chat = Chat; //# sourceMappingURL=chat.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/classifiers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Classifiers = void 0;
const classifiersClassify_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/classifiersClassify.js [app-route] (ecmascript)");
const classifiersClassifyChat_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/classifiersClassifyChat.js [app-route] (ecmascript)");
const classifiersModerate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/classifiersModerate.js [app-route] (ecmascript)");
const classifiersModerateChat_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/classifiersModerateChat.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Classifiers extends sdks_js_1.ClientSDK {
    /**
     * Moderations
     */ async moderate(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersModerate_js_1.classifiersModerate)(this, request, options));
    }
    /**
     * Chat Moderations
     */ async moderateChat(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersModerateChat_js_1.classifiersModerateChat)(this, request, options));
    }
    /**
     * Classifications
     */ async classify(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersClassify_js_1.classifiersClassify)(this, request, options));
    }
    /**
     * Chat Classifications
     */ async classifyChat(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersClassifyChat_js_1.classifiersClassifyChat)(this, request, options));
    }
}
exports.Classifiers = Classifiers; //# sourceMappingURL=classifiers.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/embeddings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Embeddings = void 0;
const embeddingsCreate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/embeddingsCreate.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Embeddings extends sdks_js_1.ClientSDK {
    /**
     * Embeddings
     *
     * @remarks
     * Embeddings
     */ async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, embeddingsCreate_js_1.embeddingsCreate)(this, request, options));
    }
}
exports.Embeddings = Embeddings; //# sourceMappingURL=embeddings.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/files.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Files = void 0;
const filesDelete_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/filesDelete.js [app-route] (ecmascript)");
const filesDownload_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/filesDownload.js [app-route] (ecmascript)");
const filesGetSignedUrl_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/filesGetSignedUrl.js [app-route] (ecmascript)");
const filesList_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/filesList.js [app-route] (ecmascript)");
const filesRetrieve_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/filesRetrieve.js [app-route] (ecmascript)");
const filesUpload_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/filesUpload.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Files extends sdks_js_1.ClientSDK {
    /**
     * Upload File
     *
     * @remarks
     * Upload a file that can be used across various endpoints.
     *
     * The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files.
     *
     * Please contact us if you need to increase these storage limits.
     */ async upload(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesUpload_js_1.filesUpload)(this, request, options));
    }
    /**
     * List Files
     *
     * @remarks
     * Returns a list of files that belong to the user's organization.
     */ async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesList_js_1.filesList)(this, request, options));
    }
    /**
     * Retrieve File
     *
     * @remarks
     * Returns information about a specific file.
     */ async retrieve(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesRetrieve_js_1.filesRetrieve)(this, request, options));
    }
    /**
     * Delete File
     *
     * @remarks
     * Delete a file.
     */ async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesDelete_js_1.filesDelete)(this, request, options));
    }
    /**
     * Download File
     *
     * @remarks
     * Download a file
     */ async download(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesDownload_js_1.filesDownload)(this, request, options));
    }
    /**
     * Get Signed Url
     */ async getSignedUrl(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesGetSignedUrl_js_1.filesGetSignedUrl)(this, request, options));
    }
}
exports.Files = Files; //# sourceMappingURL=files.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/fim.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Fim = void 0;
const fimComplete_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fimComplete.js [app-route] (ecmascript)");
const fimStream_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fimStream.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Fim extends sdks_js_1.ClientSDK {
    /**
     * Fim Completion
     *
     * @remarks
     * FIM completion.
     */ async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fimComplete_js_1.fimComplete)(this, request, options));
    }
    /**
     * Stream fim completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */ async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fimStream_js_1.fimStream)(this, request, options));
    }
}
exports.Fim = Fim; //# sourceMappingURL=fim.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/jobs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Jobs = void 0;
const fineTuningJobsCancel_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fineTuningJobsCancel.js [app-route] (ecmascript)");
const fineTuningJobsCreate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fineTuningJobsCreate.js [app-route] (ecmascript)");
const fineTuningJobsGet_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fineTuningJobsGet.js [app-route] (ecmascript)");
const fineTuningJobsList_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fineTuningJobsList.js [app-route] (ecmascript)");
const fineTuningJobsStart_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/fineTuningJobsStart.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Jobs extends sdks_js_1.ClientSDK {
    /**
     * Get Fine Tuning Jobs
     *
     * @remarks
     * Get a list of fine-tuning jobs for your organization and user.
     */ async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsList_js_1.fineTuningJobsList)(this, request, options));
    }
    /**
     * Create Fine Tuning Job
     *
     * @remarks
     * Create a new fine-tuning job, it will be queued for processing.
     */ async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsCreate_js_1.fineTuningJobsCreate)(this, request, options));
    }
    /**
     * Get Fine Tuning Job
     *
     * @remarks
     * Get a fine-tuned job details by its UUID.
     */ async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsGet_js_1.fineTuningJobsGet)(this, request, options));
    }
    /**
     * Cancel Fine Tuning Job
     *
     * @remarks
     * Request the cancellation of a fine tuning job.
     */ async cancel(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsCancel_js_1.fineTuningJobsCancel)(this, request, options));
    }
    /**
     * Start Fine Tuning Job
     *
     * @remarks
     * Request the start of a validated fine tuning job.
     */ async start(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsStart_js_1.fineTuningJobsStart)(this, request, options));
    }
}
exports.Jobs = Jobs; //# sourceMappingURL=jobs.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/finetuning.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FineTuning = void 0;
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const jobs_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/jobs.js [app-route] (ecmascript)");
class FineTuning extends sdks_js_1.ClientSDK {
    get jobs() {
        return this._jobs ?? (this._jobs = new jobs_js_1.Jobs(this._options));
    }
}
exports.FineTuning = FineTuning; //# sourceMappingURL=finetuning.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/models.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Models = void 0;
const modelsArchive_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/modelsArchive.js [app-route] (ecmascript)");
const modelsDelete_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/modelsDelete.js [app-route] (ecmascript)");
const modelsList_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/modelsList.js [app-route] (ecmascript)");
const modelsRetrieve_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/modelsRetrieve.js [app-route] (ecmascript)");
const modelsUnarchive_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/modelsUnarchive.js [app-route] (ecmascript)");
const modelsUpdate_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/modelsUpdate.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Models extends sdks_js_1.ClientSDK {
    /**
     * List Models
     *
     * @remarks
     * List all models available to the user.
     */ async list(options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsList_js_1.modelsList)(this, options));
    }
    /**
     * Retrieve Model
     *
     * @remarks
     * Retrieve a model information.
     */ async retrieve(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsRetrieve_js_1.modelsRetrieve)(this, request, options));
    }
    /**
     * Delete Model
     *
     * @remarks
     * Delete a fine-tuned model.
     */ async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsDelete_js_1.modelsDelete)(this, request, options));
    }
    /**
     * Update Fine Tuned Model
     *
     * @remarks
     * Update a model name or description.
     */ async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsUpdate_js_1.modelsUpdate)(this, request, options));
    }
    /**
     * Archive Fine Tuned Model
     *
     * @remarks
     * Archive a fine-tuned model.
     */ async archive(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsArchive_js_1.modelsArchive)(this, request, options));
    }
    /**
     * Unarchive Fine Tuned Model
     *
     * @remarks
     * Un-archive a fine-tuned model.
     */ async unarchive(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsUnarchive_js_1.modelsUnarchive)(this, request, options));
    }
}
exports.Models = Models; //# sourceMappingURL=models.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/ocr.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Ocr = void 0;
const ocrProcess_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/funcs/ocrProcess.js [app-route] (ecmascript)");
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const fp_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/types/fp.js [app-route] (ecmascript)");
class Ocr extends sdks_js_1.ClientSDK {
    /**
     * OCR
     */ async process(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, ocrProcess_js_1.ocrProcess)(this, request, options));
    }
}
exports.Ocr = Ocr; //# sourceMappingURL=ocr.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/sdk/sdk.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Mistral = void 0;
const sdks_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/sdks.js [app-route] (ecmascript)");
const agents_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/agents.js [app-route] (ecmascript)");
const batch_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/batch.js [app-route] (ecmascript)");
const beta_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/beta.js [app-route] (ecmascript)");
const chat_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/chat.js [app-route] (ecmascript)");
const classifiers_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/classifiers.js [app-route] (ecmascript)");
const embeddings_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/embeddings.js [app-route] (ecmascript)");
const files_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/files.js [app-route] (ecmascript)");
const fim_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/fim.js [app-route] (ecmascript)");
const finetuning_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/finetuning.js [app-route] (ecmascript)");
const models_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/models.js [app-route] (ecmascript)");
const ocr_js_1 = __turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/ocr.js [app-route] (ecmascript)");
class Mistral extends sdks_js_1.ClientSDK {
    get models() {
        return this._models ?? (this._models = new models_js_1.Models(this._options));
    }
    get beta() {
        return this._beta ?? (this._beta = new beta_js_1.Beta(this._options));
    }
    get files() {
        return this._files ?? (this._files = new files_js_1.Files(this._options));
    }
    get fineTuning() {
        return this._fineTuning ?? (this._fineTuning = new finetuning_js_1.FineTuning(this._options));
    }
    get batch() {
        return this._batch ?? (this._batch = new batch_js_1.Batch(this._options));
    }
    get chat() {
        return this._chat ?? (this._chat = new chat_js_1.Chat(this._options));
    }
    get fim() {
        return this._fim ?? (this._fim = new fim_js_1.Fim(this._options));
    }
    get agents() {
        return this._agents ?? (this._agents = new agents_js_1.Agents(this._options));
    }
    get embeddings() {
        return this._embeddings ?? (this._embeddings = new embeddings_js_1.Embeddings(this._options));
    }
    get classifiers() {
        return this._classifiers ?? (this._classifiers = new classifiers_js_1.Classifiers(this._options));
    }
    get ocr() {
        return this._ocr ?? (this._ocr = new ocr_js_1.Ocr(this._options));
    }
}
exports.Mistral = Mistral; //# sourceMappingURL=sdk.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/extra/structChat.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transformToChatCompletionRequest = transformToChatCompletionRequest;
exports.convertToParsedChatCompletionResponse = convertToParsedChatCompletionResponse;
exports.responseFormatFromZodObject = responseFormatFromZodObject;
const zod_to_json_schema_1 = __turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)");
function transformToChatCompletionRequest(parsedRequest) {
    const { responseFormat, ...rest } = parsedRequest;
    // Transform responseFormat from z.ZodType to ResponseFormat
    const transformedResponseFormat = responseFormatFromZodObject(responseFormat);
    return {
        ...rest,
        responseFormat: transformedResponseFormat
    };
}
function convertToParsedChatCompletionResponse(response, responseFormat) {
    if (response.choices === undefined || response.choices.length === 0) {
        return {
            ...response,
            choices: response.choices === undefined ? undefined : []
        };
    }
    const parsedChoices = [];
    for (const _choice of response.choices){
        if (_choice.message === null || typeof _choice.message === 'undefined') {
            parsedChoices.push({
                ..._choice,
                message: undefined
            });
        } else {
            if (_choice.message.content !== null && typeof _choice.message.content !== 'undefined' && !Array.isArray(_choice.message.content)) {
                parsedChoices.push({
                    ..._choice,
                    message: {
                        ..._choice.message,
                        parsed: responseFormat.safeParse(JSON.parse(_choice.message.content)).data
                    }
                });
            }
        }
    }
    return {
        ...response,
        choices: parsedChoices
    };
}
// Function to convert Zod schema to strict JSON schema
function responseFormatFromZodObject(responseFormat) {
    const responseJsonSchema = (0, zod_to_json_schema_1.zodToJsonSchema)(responseFormat);
    // It is not possible to get the variable name of a Zod object at runtime in TypeScript so we're using a placeholder name.
    // This has not impact on the parsing as the initial Zod object is used to parse the response.
    const placeholderName = "placeholderName";
    return {
        type: "json_schema",
        jsonSchema: {
            name: placeholderName,
            schemaDefinition: responseJsonSchema,
            strict: true
        }
    };
} //# sourceMappingURL=structChat.js.map
}}),
"[project]/node_modules/@mistralai/mistralai/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.files = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/config.js [app-route] (ecmascript)"), exports);
exports.files = __importStar(__turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/lib/files.js [app-route] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@mistralai/mistralai/sdk/sdk.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_%40mistralai_mistralai_73a45732._.js.map